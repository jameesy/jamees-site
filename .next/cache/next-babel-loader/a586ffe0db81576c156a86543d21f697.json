{"ast":null,"code":"import { Sema } from 'async-sema';\nimport rpc, { values } from './rpc';\nimport getTableData from './getTableData';\nimport { getPostPreview } from './getPostPreview';\nimport { BLOG_INDEX_ID } from './server-constants';\nexport default async function getBlogIndex(previews = true) {\n  let postsTable = null;\n\n  if (!postsTable) {\n    try {\n      const data = await rpc('loadPageChunk', {\n        pageId: BLOG_INDEX_ID,\n        limit: 999,\n        // TODO: figure out Notion's way of handling pagination\n        cursor: {\n          stack: []\n        },\n        chunkNumber: 0,\n        verticalColumns: false\n      }); // Parse table with posts\n\n      const tableBlock = values(data.recordMap.block).find(block => block.value.type === 'collection_view');\n      postsTable = await getTableData(tableBlock, true);\n    } catch (err) {\n      console.error(`\\nFailed to load Notion posts, did you configure your Notion table as an inline table according to https://github.com/ijjk/notion-blog#creating-your-pages-table\\n`);\n      console.error(err);\n      postsTable = {};\n    } // only get 10 most recent post's previews\n\n\n    const postsKeys = Object.keys(postsTable).splice(0, 10);\n    const sema = new Sema(3, {\n      capacity: postsKeys.length\n    });\n\n    if (previews) {\n      await Promise.all(postsKeys.sort((a, b) => {\n        const postA = postsTable[a];\n        const postB = postsTable[b];\n        const timeA = postA.Date;\n        const timeB = postB.Date;\n        return Math.sign(timeB - timeA);\n      }).map(async postKey => {\n        await sema.acquire();\n        const post = postsTable[postKey];\n        post.preview = post.id ? await getPostPreview(postsTable[postKey].id) : [];\n        sema.release();\n      }));\n    }\n  }\n\n  return postsTable;\n}","map":{"version":3,"sources":["/Users/jamesbedford/Documents/GitHub/jamees-site/src/lib/notion/getBlogIndex.ts"],"names":["Sema","rpc","values","getTableData","getPostPreview","BLOG_INDEX_ID","getBlogIndex","previews","postsTable","data","pageId","limit","cursor","stack","chunkNumber","verticalColumns","tableBlock","recordMap","block","find","value","type","err","console","error","postsKeys","Object","keys","splice","sema","capacity","length","Promise","all","sort","a","b","postA","postB","timeA","Date","timeB","Math","sign","map","postKey","acquire","post","preview","id","release"],"mappings":"AAAA,SAASA,IAAT,QAAqB,YAArB;AACA,OAAOC,GAAP,IAAcC,MAAd,QAA4B,OAA5B;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AACA,SAASC,cAAT,QAA+B,kBAA/B;AACA,SAASC,aAAT,QAA8B,oBAA9B;AAEA,eAAe,eAAeC,YAAf,CAA4BC,QAAQ,GAAG,IAAvC,EAA6C;AAC1D,MAAIC,UAAe,GAAG,IAAtB;;AAEA,MAAI,CAACA,UAAL,EAAiB;AACf,QAAI;AACF,YAAMC,IAAI,GAAG,MAAMR,GAAG,CAAC,eAAD,EAAkB;AACtCS,QAAAA,MAAM,EAAEL,aAD8B;AAEtCM,QAAAA,KAAK,EAAE,GAF+B;AAE1B;AACZC,QAAAA,MAAM,EAAE;AAAEC,UAAAA,KAAK,EAAE;AAAT,SAH8B;AAItCC,QAAAA,WAAW,EAAE,CAJyB;AAKtCC,QAAAA,eAAe,EAAE;AALqB,OAAlB,CAAtB,CADE,CASF;;AACA,YAAMC,UAAU,GAAGd,MAAM,CAACO,IAAI,CAACQ,SAAL,CAAeC,KAAhB,CAAN,CAA6BC,IAA7B,CAChBD,KAAD,IAAgBA,KAAK,CAACE,KAAN,CAAYC,IAAZ,KAAqB,iBADpB,CAAnB;AAIAb,MAAAA,UAAU,GAAG,MAAML,YAAY,CAACa,UAAD,EAAa,IAAb,CAA/B;AACD,KAfD,CAeE,OAAOM,GAAP,EAAY;AACZC,MAAAA,OAAO,CAACC,KAAR,CACG,oKADH;AAGAD,MAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACAd,MAAAA,UAAU,GAAG,EAAb;AACD,KAtBc,CAwBf;;;AACA,UAAMiB,SAAS,GAAGC,MAAM,CAACC,IAAP,CAAYnB,UAAZ,EAAwBoB,MAAxB,CAA+B,CAA/B,EAAkC,EAAlC,CAAlB;AAEA,UAAMC,IAAI,GAAG,IAAI7B,IAAJ,CAAS,CAAT,EAAY;AAAE8B,MAAAA,QAAQ,EAAEL,SAAS,CAACM;AAAtB,KAAZ,CAAb;;AAEA,QAAIxB,QAAJ,EAAc;AACZ,YAAMyB,OAAO,CAACC,GAAR,CACJR,SAAS,CACNS,IADH,CACQ,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACd,cAAMC,KAAK,GAAG7B,UAAU,CAAC2B,CAAD,CAAxB;AACA,cAAMG,KAAK,GAAG9B,UAAU,CAAC4B,CAAD,CAAxB;AACA,cAAMG,KAAK,GAAGF,KAAK,CAACG,IAApB;AACA,cAAMC,KAAK,GAAGH,KAAK,CAACE,IAApB;AACA,eAAOE,IAAI,CAACC,IAAL,CAAUF,KAAK,GAAGF,KAAlB,CAAP;AACD,OAPH,EAQGK,GARH,CAQO,MAAMC,OAAN,IAAiB;AACpB,cAAMhB,IAAI,CAACiB,OAAL,EAAN;AACA,cAAMC,IAAI,GAAGvC,UAAU,CAACqC,OAAD,CAAvB;AACAE,QAAAA,IAAI,CAACC,OAAL,GAAeD,IAAI,CAACE,EAAL,GACX,MAAM7C,cAAc,CAACI,UAAU,CAACqC,OAAD,CAAV,CAAoBI,EAArB,CADT,GAEX,EAFJ;AAGApB,QAAAA,IAAI,CAACqB,OAAL;AACD,OAfH,CADI,CAAN;AAkBD;AACF;;AAED,SAAO1C,UAAP;AACD","sourcesContent":["import { Sema } from 'async-sema'\nimport rpc, { values } from './rpc'\nimport getTableData from './getTableData'\nimport { getPostPreview } from './getPostPreview'\nimport { BLOG_INDEX_ID } from './server-constants'\n\nexport default async function getBlogIndex(previews = true) {\n  let postsTable: any = null\n\n  if (!postsTable) {\n    try {\n      const data = await rpc('loadPageChunk', {\n        pageId: BLOG_INDEX_ID,\n        limit: 999, // TODO: figure out Notion's way of handling pagination\n        cursor: { stack: [] },\n        chunkNumber: 0,\n        verticalColumns: false,\n      })\n\n      // Parse table with posts\n      const tableBlock = values(data.recordMap.block).find(\n        (block: any) => block.value.type === 'collection_view'\n      )\n\n      postsTable = await getTableData(tableBlock, true)\n    } catch (err) {\n      console.error(\n        `\\nFailed to load Notion posts, did you configure your Notion table as an inline table according to https://github.com/ijjk/notion-blog#creating-your-pages-table\\n`\n      )\n      console.error(err)\n      postsTable = {}\n    }\n\n    // only get 10 most recent post's previews\n    const postsKeys = Object.keys(postsTable).splice(0, 10)\n\n    const sema = new Sema(3, { capacity: postsKeys.length })\n\n    if (previews) {\n      await Promise.all(\n        postsKeys\n          .sort((a, b) => {\n            const postA = postsTable[a]\n            const postB = postsTable[b]\n            const timeA = postA.Date\n            const timeB = postB.Date\n            return Math.sign(timeB - timeA)\n          })\n          .map(async postKey => {\n            await sema.acquire()\n            const post = postsTable[postKey]\n            post.preview = post.id\n              ? await getPostPreview(postsTable[postKey].id)\n              : []\n            sema.release()\n          })\n      )\n    }\n  }\n\n  return postsTable\n}\n"]},"metadata":{},"sourceType":"module"}