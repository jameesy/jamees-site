{"ast":null,"code":"import { Sema } from 'async-sema';\nimport rpc, { values } from './rpc';\nimport getTableData from './getTableData';\nimport { getPostPreview } from './getPostPreview';\nimport { BLOG_INDEX_ID } from './server-constants';\nexport default async function getBlogIndex(previews = true) {\n  let postsTable = null;\n\n  if (!postsTable) {\n    try {\n      const data = await rpc('loadPageChunk', {\n        pageId: BLOG_INDEX_ID,\n        limit: 999,\n        // TODO: figure out Notion's way of handling pagination\n        cursor: {\n          stack: []\n        },\n        chunkNumber: 0,\n        verticalColumns: false\n      }); // Parse table with posts\n\n      const tableBlock = values(data.recordMap.block).find(block => block.value.type === 'collection_view');\n      postsTable = await getTableData(tableBlock, true);\n    } catch (err) {\n      console.error(`\\nFailed to load Notion posts, did you configure your Notion table as an inline table according to https://github.com/ijjk/notion-blog#creating-your-pages-table\\n`);\n      console.error(err);\n      postsTable = {};\n    } // only get 10 most recent post's previews\n\n\n    const postsKeys = Object.keys(postsTable).splice(0, 10);\n    const sema = new Sema(3, {\n      capacity: postsKeys.length\n    });\n\n    if (previews) {\n      await Promise.all(postsKeys.sort((a, b) => {\n        const postA = postsTable[a];\n        const postB = postsTable[b];\n        const timeA = postA.Date;\n        const timeB = postB.Date;\n        return Math.sign(timeB - timeA);\n      }).map(async postKey => {\n        await sema.acquire();\n        const post = postsTable[postKey];\n        post.preview = post.id ? await getPostPreview(postsTable[postKey].id) : [];\n        sema.release();\n      }));\n    }\n  }\n\n  return postsTable;\n}","map":null,"metadata":{},"sourceType":"module"}