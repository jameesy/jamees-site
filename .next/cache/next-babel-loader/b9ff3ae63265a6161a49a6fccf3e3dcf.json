{"ast":null,"code":"import rpc, { values } from './rpc';\nconst PAGE_LIMIT = 100;\nexport default async function getPageData(pageId, skip = 3) {\n  try {\n    let blocks = [];\n    let chunkNumber = 0;\n    let currentPage;\n    let currentCursor = {\n      stack: []\n    };\n\n    do {\n      // hit page limit, load next page\n      const nextBlock = await loadPageChunk({\n        pageId,\n        cursor: currentCursor,\n        chunkNumber\n      });\n      currentPage = values(nextBlock.recordMap.block);\n      currentCursor = {\n        stack: [nextBlock.cursor.stack[0]]\n      };\n      chunkNumber++;\n\n      if (currentPage[0] && currentPage[0].value.content) {\n        // remove table blocks\n        currentPage.splice(0, skip);\n      }\n\n      blocks = blocks.concat(currentPage);\n    } while (currentPage.length >= PAGE_LIMIT);\n\n    return {\n      blocks\n    };\n  } catch (err) {\n    console.error(`Failed to load pageData for ${pageId}`, err);\n    return {\n      blocks: []\n    };\n  }\n}\nexport function loadPageChunk({\n  pageId,\n  limit = PAGE_LIMIT,\n  cursor = {\n    stack: []\n  },\n  chunkNumber = 0,\n  verticalColumns = false\n}) {\n  return rpc('loadPageChunk', {\n    pageId,\n    limit,\n    cursor,\n    chunkNumber,\n    verticalColumns\n  });\n}","map":{"version":3,"sources":["/Users/jamesbedford/Documents/GitHub/jamees-site/src/lib/notion/getPageData.ts"],"names":["rpc","values","PAGE_LIMIT","getPageData","pageId","skip","blocks","chunkNumber","currentPage","currentCursor","stack","nextBlock","loadPageChunk","cursor","recordMap","block","value","content","splice","concat","length","err","console","error","limit","verticalColumns"],"mappings":"AAAA,OAAOA,GAAP,IAAcC,MAAd,QAA4B,OAA5B;AAEA,MAAMC,UAAU,GAAG,GAAnB;AAEA,eAAe,eAAeC,WAAf,CAA2BC,MAA3B,EAA2CC,IAAI,GAAG,CAAlD,EAAqD;AAClE,MAAI;AACF,QAAIC,MAAM,GAAG,EAAb;AAEA,QAAIC,WAAW,GAAG,CAAlB;AACA,QAAIC,WAAJ;AACA,QAAIC,aAAa,GAAG;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAApB;;AAEA,OAAG;AACD;AACA,YAAMC,SAAS,GAAG,MAAMC,aAAa,CAAC;AACpCR,QAAAA,MADoC;AAEpCS,QAAAA,MAAM,EAAEJ,aAF4B;AAGpCF,QAAAA;AAHoC,OAAD,CAArC;AAKAC,MAAAA,WAAW,GAAGP,MAAM,CAACU,SAAS,CAACG,SAAV,CAAoBC,KAArB,CAApB;AACAN,MAAAA,aAAa,GAAG;AAAEC,QAAAA,KAAK,EAAE,CAACC,SAAS,CAACE,MAAV,CAAiBH,KAAjB,CAAuB,CAAvB,CAAD;AAAT,OAAhB;AACAH,MAAAA,WAAW;;AAEX,UAAIC,WAAW,CAAC,CAAD,CAAX,IAAkBA,WAAW,CAAC,CAAD,CAAX,CAAeQ,KAAf,CAAqBC,OAA3C,EAAoD;AAClD;AACAT,QAAAA,WAAW,CAACU,MAAZ,CAAmB,CAAnB,EAAsBb,IAAtB;AACD;;AAEDC,MAAAA,MAAM,GAAGA,MAAM,CAACa,MAAP,CAAcX,WAAd,CAAT;AACD,KAjBD,QAiBSA,WAAW,CAACY,MAAZ,IAAsBlB,UAjB/B;;AAmBA,WAAO;AAAEI,MAAAA;AAAF,KAAP;AACD,GA3BD,CA2BE,OAAOe,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAe,+BAA8BnB,MAAO,EAApD,EAAuDiB,GAAvD;AACA,WAAO;AAAEf,MAAAA,MAAM,EAAE;AAAV,KAAP;AACD;AACF;AAED,OAAO,SAASM,aAAT,CAAuB;AAC5BR,EAAAA,MAD4B;AAE5BoB,EAAAA,KAAK,GAAGtB,UAFoB;AAG5BW,EAAAA,MAAM,GAAG;AAAEH,IAAAA,KAAK,EAAE;AAAT,GAHmB;AAI5BH,EAAAA,WAAW,GAAG,CAJc;AAK5BkB,EAAAA,eAAe,GAAG;AALU,CAAvB,EAMC;AACN,SAAOzB,GAAG,CAAC,eAAD,EAAkB;AAC1BI,IAAAA,MAD0B;AAE1BoB,IAAAA,KAF0B;AAG1BX,IAAAA,MAH0B;AAI1BN,IAAAA,WAJ0B;AAK1BkB,IAAAA;AAL0B,GAAlB,CAAV;AAOD","sourcesContent":["import rpc, { values } from './rpc'\n\nconst PAGE_LIMIT = 100\n\nexport default async function getPageData(pageId: string, skip = 3) {\n  try {\n    let blocks = []\n\n    let chunkNumber = 0\n    let currentPage\n    let currentCursor = { stack: [] }\n\n    do {\n      // hit page limit, load next page\n      const nextBlock = await loadPageChunk({\n        pageId,\n        cursor: currentCursor,\n        chunkNumber,\n      })\n      currentPage = values(nextBlock.recordMap.block)\n      currentCursor = { stack: [nextBlock.cursor.stack[0]] }\n      chunkNumber++\n\n      if (currentPage[0] && currentPage[0].value.content) {\n        // remove table blocks\n        currentPage.splice(0, skip)\n      }\n\n      blocks = blocks.concat(currentPage)\n    } while (currentPage.length >= PAGE_LIMIT)\n\n    return { blocks }\n  } catch (err) {\n    console.error(`Failed to load pageData for ${pageId}`, err)\n    return { blocks: [] }\n  }\n}\n\nexport function loadPageChunk({\n  pageId,\n  limit = PAGE_LIMIT,\n  cursor = { stack: [] },\n  chunkNumber = 0,\n  verticalColumns = false,\n}: any) {\n  return rpc('loadPageChunk', {\n    pageId,\n    limit,\n    cursor,\n    chunkNumber,\n    verticalColumns,\n  })\n}\n"]},"metadata":{},"sourceType":"module"}