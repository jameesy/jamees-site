{"ast":null,"code":"import { values } from './rpc';\nimport queryCollection from './queryCollection';\nimport Slugger from 'github-slugger';\nexport default async function loadTable(collectionBlock, isPosts = false) {\n  const slugger = new Slugger();\n  const {\n    value\n  } = collectionBlock;\n  let table = {};\n  const col = await queryCollection({\n    collectionId: value.collection_id,\n    collectionViewId: value.view_ids[0]\n  });\n  const entries = values(col.recordMap.block).filter(block => {\n    return block.value && block.value.parent_id === value.collection_id;\n  });\n  const colId = Object.keys(col.recordMap.collection)[0];\n  const schema = col.recordMap.collection[colId].value.schema;\n  const schemaKeys = Object.keys(schema);\n\n  for (const entry of entries) {\n    const props = entry.value && entry.value.properties;\n    const row = {};\n    if (!props) continue;\n\n    if (entry.value.content) {\n      row.id = entry.value.id;\n    }\n\n    schemaKeys.forEach(key => {\n      // might be undefined\n      let val = props[key] && props[key][0][0]; // authors and blocks are centralized\n\n      if (val && props[key][0][1]) {\n        const type = props[key][0][1][0];\n\n        switch (type[0]) {\n          case 'a':\n            // link\n            val = type[1];\n            break;\n\n          case 'u':\n            // user\n            val = props[key].filter(arr => arr.length > 1).map(arr => arr[1][0][1]);\n            break;\n\n          case 'p':\n            // page (block)\n            const page = col.recordMap.block[type[1]];\n            row.id = page.value.id;\n            val = page.value.properties.title[0][0];\n            break;\n\n          case 'd':\n            // date\n            // start_date: 2019-06-18\n            // start_time: 07:00\n            // time_zone: Europe/Berlin, America/Los_Angeles\n            if (!type[1].start_date) {\n              break;\n            } // initial with provided date\n\n\n            const providedDate = new Date(type[1].start_date + ' ' + (type[1].start_time || '')).getTime(); // calculate offset from provided time zone\n\n            const timezoneOffset = new Date(new Date().toLocaleString('en-US', {\n              timeZone: type[1].time_zone\n            })).getTime() - new Date().getTime(); // initialize subtracting time zone offset\n\n            val = new Date(providedDate - timezoneOffset).getTime();\n            break;\n\n          default:\n            console.error('unknown type', type[0], type);\n            break;\n        }\n      }\n\n      if (typeof val === 'string') {\n        val = val.trim();\n      }\n\n      row[schema[key].name] = val || null;\n    }); // auto-generate slug from title\n\n    row.Slug = row.Slug || slugger.slug(row.Page || '');\n    const key = row.Slug;\n    if (isPosts && !key) continue;\n\n    if (key) {\n      table[key] = row;\n    } else {\n      if (!Array.isArray(table)) table = [];\n      table.push(row);\n    }\n  }\n\n  return table;\n}","map":{"version":3,"sources":["/Users/jamesbedford/Documents/GitHub/jamees-site/src/lib/notion/getTableData.ts"],"names":["values","queryCollection","Slugger","loadTable","collectionBlock","isPosts","slugger","value","table","col","collectionId","collection_id","collectionViewId","view_ids","entries","recordMap","block","filter","parent_id","colId","Object","keys","collection","schema","schemaKeys","entry","props","properties","row","content","id","forEach","key","val","type","arr","length","map","page","title","start_date","providedDate","Date","start_time","getTime","timezoneOffset","toLocaleString","timeZone","time_zone","console","error","trim","name","Slug","slug","Page","Array","isArray","push"],"mappings":"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","sourcesContent":["import { values } from './rpc'\nimport queryCollection from './queryCollection'\nimport Slugger from 'github-slugger'\n\nexport default async function loadTable(collectionBlock: any, isPosts = false) {\n  const slugger = new Slugger()\n\n  const { value } = collectionBlock\n  let table: any = {}\n  const col = await queryCollection({\n    collectionId: value.collection_id,\n    collectionViewId: value.view_ids[0],\n  })\n  const entries = values(col.recordMap.block).filter((block: any) => {\n    return block.value && block.value.parent_id === value.collection_id\n  })\n\n  const colId = Object.keys(col.recordMap.collection)[0]\n  const schema = col.recordMap.collection[colId].value.schema\n  const schemaKeys = Object.keys(schema)\n\n  for (const entry of entries) {\n    const props = entry.value && entry.value.properties\n    const row: any = {}\n\n    if (!props) continue\n    if (entry.value.content) {\n      row.id = entry.value.id\n    }\n\n    schemaKeys.forEach(key => {\n      // might be undefined\n      let val = props[key] && props[key][0][0]\n\n      // authors and blocks are centralized\n      if (val && props[key][0][1]) {\n        const type = props[key][0][1][0]\n\n        switch (type[0]) {\n          case 'a': // link\n            val = type[1]\n            break\n          case 'u': // user\n            val = props[key]\n              .filter((arr: any[]) => arr.length > 1)\n              .map((arr: any[]) => arr[1][0][1])\n            break\n          case 'p': // page (block)\n            const page = col.recordMap.block[type[1]]\n            row.id = page.value.id\n            val = page.value.properties.title[0][0]\n            break\n          case 'd': // date\n            // start_date: 2019-06-18\n            // start_time: 07:00\n            // time_zone: Europe/Berlin, America/Los_Angeles\n\n            if (!type[1].start_date) {\n              break\n            }\n            // initial with provided date\n            const providedDate = new Date(\n              type[1].start_date + ' ' + (type[1].start_time || '')\n            ).getTime()\n\n            // calculate offset from provided time zone\n            const timezoneOffset =\n              new Date(\n                new Date().toLocaleString('en-US', {\n                  timeZone: type[1].time_zone,\n                })\n              ).getTime() - new Date().getTime()\n\n            // initialize subtracting time zone offset\n            val = new Date(providedDate - timezoneOffset).getTime()\n            break\n          default:\n            console.error('unknown type', type[0], type)\n            break\n        }\n      }\n\n      if (typeof val === 'string') {\n        val = val.trim()\n      }\n      row[schema[key].name] = val || null\n    })\n\n    // auto-generate slug from title\n    row.Slug = row.Slug || slugger.slug(row.Page || '')\n\n    const key = row.Slug\n    if (isPosts && !key) continue\n\n    if (key) {\n      table[key] = row\n    } else {\n      if (!Array.isArray(table)) table = []\n      table.push(row)\n    }\n  }\n  return table\n}\n"]},"metadata":{},"sourceType":"module"}